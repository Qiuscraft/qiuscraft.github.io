---
title: 【算法导论】牛径问题
categories: 算法导论
---
***27-1 Cow-path problem***
The Appalachian Trail (AT) is a marked hiking trail in the eastern United States extending between Springer Mountain in Georgia and Mount Katahdin in Maine. The trail is about 2,190 miles long. You decide that you are going to hike the AT from Georgia to Maine and back. You plan to learn more about algorithms while on the trail, and so you bring along your copy of Introduction to Algorithms in your backpack. ${ }^2$ You have already read through this chapter before starting out. Because the beauty of the trail distracts you, you forget about reading this book until you have reached Maine and hiked halfway back to Georgia. At that point, you decide that you have already seen the trail and want to continue reading the rest of the book, starting with Chapter 28. Unfortunately, you find that the book is no longer in your pack. You must have left it somewhere along the trail, but you don't know where. It could be anywhere between Georgia and Maine. You want to find the book, but now that you have learned something about online algorithms, you want your algorithm for finding it to have a good competitive ratio. That is, no matter where the book is, if its distance from you is $x$ miles away, you would like to be sure that you do not walk more than $c x$ miles to find it, for some constant $c$. You do not know $x$, though you may assume that $x \geq 1 .^3$

What algorithm should you use, and what constant $c$ can you prove bounds the total distance $c x$ that you would have to walk? Your algorithm should work for a trail of any length, not just the 2,190 -mile-long AT.

---

${ }^2$ This book is heavy. We do not recommend that you carry it on a long hike.
${ }^3$ In case you're wondering what this problem has to do with cows, some papers about it frame the problem as a cow looking for a field in which to graze.

---

算法：

先随意确定一个正方向。

第$1$步：向正方向走$1$英里，如果没有找到，再反方向走$1$英里，回到原点。

第$2$步：向反方向走$2$英里，如果没有找到，再正方向走$2$英里，回到原点。

以此类推，每一步的搜索距离都是上一步的两倍，每一步的搜索方向都与上一步相反。直到找到书，算法终止。

竞争比计算：

第$i$步：向某方向走$2^{i-1}$英里，如果没有找到，再向某方向的反方向方向走$2^{i-1}$英里，回到原点。这一步共走$2^i$英里。

容易知$\exists j \in N, 2^j \lt x \le 2^{j+1}$。

那么此算法的前$j+1$步都不会找到书。完成第$1$步到第$j+1$步这段路程共$\sum_{k=1}\ ^{j+1} 2^k = 2^{j+2} - 2$英里。

考虑最坏的情况，第$j+2$步，我们朝某一个方向走了$2^{j+1}$英里，但是这个方向不是书所在的方向，因此我们还是没找到书。

于是，在第$j+3$步，我们朝着正确的方向走了$x$英里，找到了书。

全程走的总路程为

$$2^{j+2}-2+2^{j+2}+x=2^{j+3}-2+x \lt 9x-2$$

故竞争比为9。

