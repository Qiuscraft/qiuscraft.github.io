---
title: 【算法导论】套利交易 动态图的传递闭包
categories: 算法导论
date: 2025-11-25 13:41:00
---

【算法导论】栏目文章旨在记录我在学习《算法导论》的过程中所做的题目，并分享我最终整理出的我认为比较标准的解答，供大家参考，欢迎指正。

---

**24-3** （套利交易）

套利交易指的是使用货币汇率之间的差异来将一个单位的货币转换为多于一个单位的同种货币的行为。例如，假定 1 美元可以买 49 印度卢比，1 印度卢比可以买 2 日元，1 日元可以购买 0.0107 美元。那么通过在货币之间进行转换，一个交易商可以从 1 美元开始，购买 $49 \times 2 \times 0.0107 = 1.0486$ 美元，从而获得 4.86% 的利润。

假设给定 $n$ 种货币 $c_1, c_2, \dots, c_n$ 和一个 $n \times n$ 的汇率表 $R$，一个单位的 $c_i$ 货币可以购买 $R[i, j]$ 单位的 $c_j$ 货币。

a. 给出一个有效的算法来判断是否存在在一个货币序列 $\langle c_{i_1}, c_{i_2}, \dots, c_{i_k} \rangle$，使得
$R[i_1, i_2] \cdot R[i_2, i_3] \cdot \dots \cdot R[i_{k-1}, i_k] \cdot R[i_k, i_1] > 1$  
请分析算法的运行时间。

b. 给出一个有效算法来打印出这样的一个序列（如果存在这样一种序列）。分析算法的运行时间。

a. $R[i_1, i_2] \cdot R[i_2, i_3] \cdot \dots \cdot R[i_{k-1}, i_k] \cdot R[i_k, i_1] > 1$

​    $\Leftrightarrow \log (R[i_1, i_2] \cdot R[i_2, i_3] \cdot \dots \cdot R[i_{k-1}, i_k] \cdot R[i_k, i_1]) > 0$

​    $\Leftrightarrow \log R[i_1, i_2] + \log R[i_2, i_3] + \dots + \log R[i_{k-1}, i_k] + \log R[i_k, i_1]) > 0$

​    $\Leftrightarrow w[i_1, i_2] + w[i_2, i_3] + \dots + w[i_{k-1}, i_k] + w[i_k, i_1] < 0$，其中$w[i_r, i_s] = -\log R[i_r, i_s]$。

​    于是作出$n$个顶点，每个顶点代表一种货币，每个顶点两两连线，边$(v_r, v_s)$的权重为$-\log R[r, s]$的带权有向图。由于对任意两个顶点$v_r, v_s$，都存在边$(v_r, v_s)$，于是只需随便挑选一个顶点$v_0$，以它为源点使用Bellman-Ford算法，如果找到负权重环，那么就存在这个序列。算法运行时间为$O(|V||E|) = O(n^3)$

b. 通过应用a中的方法，我们通过Bellman-Ford算法，执行$n-1$次松弛后，我们将此时的$d(v_1), d(v_2), ..., d(v_{n-1})$记为$d^{(n-1)}(v_1), d^{(n-1)}(v_2), ..., d^{(n-1)}(v_{n-1})$，将执行$n$次松弛后的$d(v_1), d(v_2), ..., d(v_{n-1})$记为$d^{(n)}(v_1), d^{(n)}(v_2), ..., d^{(n)}(v_{n-1})$。

​    如果存在负权重环，那么我们将找到一个顶点集合$S$，$\forall v \in S, d^{(n)}(v) \neq d^{(n-1)}(v)$。同时，我们还需要在应用Bellman-Ford算法的过程中，记录一个大小为$n$数组$prev[n]$，$prev[v]$的值$i$表示让$d^{(n)}(v) \neq d^{(n-1)}(v)$的那条边$(v_i, v)$，通过这个数组，我们就可以还原出整个负权重环。还原环的时间是$O(n)$，但是执行a中的算法需要$O(n^3)$，所以共需时间$O(n^3)$。

---

**25-1**  （动态图的传递闭包）

假定我们希望在将边插入到集合 $E$ 中时维持有向图 $G = (V, E)$ 的传递闭包，即在插入每条边后，我们希望对到目前为止已插入边的传递闭包进行更新。假定图 $G$ 开始时不包含任何边，并且传递闭包用布尔矩阵来表示。

a. 说明在加入一条新边到图 $G$ 时，如何在 $O(V^2)$ 时间内更新图 $G = (V, E)$ 的传递闭包 $G^* = (V, E^*)$。

b. 给出一个图 $G$ 和一条边 $e$，使得在将边 $e$ 插入到图 $G$ 后，更新传递闭包的时间复杂性为 $\Omega(V^2)$，而不管使用的是什么算法。

c. 描述一个有效的算法，使得在将边加入到图 $G$ 中时更新传递闭包。对于任意 $n$ 次插入的序列，算法运行的总时间应该是 $\sum_{i=1}^n t_i = O(V^3)$，其中 $t_i$ 是插入第 $i$ 条边时更新传递闭包所用的时间。请证明你的算法确实达到了这个时间效率。

a. 假设添加的边为$(x_1, x_2)$。考虑每一对顶点$(u, v)$，如果$(u, v) \notin G^*$，且$(u, x_1) \in G^*, (x_2, v) \in G^*$，那么将$(u, v)$添加到$G^*$中。这可以在$O(V^2)$时间内完成。

b. 存在必须花费 $\Omega(V^2)$ 时间的插入
- 构造：令 $V=\{u,v\}\cup X\cup Y$，其中 $|X|=|Y|=(V-2)/2$。初始边集
  - 对每个 $x\in X$ 加边 $x\to u$；
  - 对每个 $y\in Y$ 加边 $v\to y$；
  - 无其他边。
- 插入 $e=(u,v)$ 前，任意 $x\in X$ 到任意 $y\in Y$ 不可达；插入后经 $x\to u\to v\to y$ 全部可达。
- 用$G_1$表示原始的传递闭包，用$G_2$表示更新后的传递闭包，因而有
$$
|\{(x,y)\in X\times Y : (x, y) \notin G_1, (x, y) \in G_2| \;=\; |X||Y|\;=\;\Theta(V^2),
$$
- 任何正确算法都必须至少“触及/更新”这 $\Theta(V^2)$ 个矩阵项，故时间为 $\Omega(V^2)$。

c. 

- 对每个顶点 $w\in V$，维护两个集合：
  - $\mathrm{Pred}[w]=\{x\in V:\ x\leadsto w\}$（到 $w$ 的所有可达源）；
  - $\mathrm{Succ}[w]=\{y\in V:\ w\leadsto y\}$（从 $w$ 可达的所有顶点）。
- 约定零长度路径可达：对任意 $w$，$w\in \mathrm{Pred}[w]\cap \mathrm{Succ}[w]$。
- 传递闭包即
  $$
  E^*=\{(x,y)\in V\times V:\ y\in \mathrm{Succ}[x]\}
  \;=\;
  \{(x,y)\in V\times V:\ x\in \mathrm{Pred}[y]\}.
  $$

插入边 $(u,v)$ 的更新算法
- 若 $v\in \mathrm{Succ}[u]$，直接返回（无新信息）。
- 否则，对每个 $x\in \mathrm{Pred}[u]$ 且满足 $v\notin \mathrm{Succ}[x]$，执行一次整集合并：
  1) 令 $\mathrm{Succ}[x]\leftarrow \mathrm{Succ}[x]\cup \mathrm{Succ}[v]$；
  2) 对所有新加入的 $y\in \mathrm{Succ}[x]$，同步加入 $x$ 到 $\mathrm{Pred}[y]$（保持两侧一致）。

总时间界
- 触发一次并集操作 $\mathrm{Succ}[x]\leftarrow \mathrm{Succ}[x]\cup \mathrm{Succ}[v]$ 的充要条件是先前 $v\notin \mathrm{Succ}[x]$。对固定有序对 $(x,v)$，此事至多发生一次；共有至多 $V^2$ 次并集，每次成本 $O(V)$，合计
  $$
  O(V^2)\cdot O(V)=O(V^3).
  $$
- 遍历 $\mathrm{Pred}[u]$ 的代价总计不超过上述主项，同阶为 $O(V^3)$。
